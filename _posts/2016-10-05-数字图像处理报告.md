---
layout: post
title: 数字图像处理
tags:
- 流媒体
categories: 流媒体服务
description: 一个搜集流媒体信息的大杂烩。
---

#《数字图像处理》

> 一、	简述Computer Imaging、Computer Vision、Image Processing的研究对象及其相互关系。（15分）

> 二、	简述DFT的公式，二维DFT的基本思想、步骤，并编程实现4*4图像的FFT蝶形图。（20分）

> 三、	简述图像复原的数学模型。（15分）


> 四、	简述小波变换与傅里叶变换相比的特点。（20分）

> 五、	简述DCT变换对图像进行压缩的基本原理，并编写出JPEG压缩的MATLAB程序（30分）

##1. Computer Imaging,Computer Vision&Image Processing

###Computer Imaging

Computer Imaging即计算机成像。计算机成像是根据一系列数学运算将图像转变成人们熟悉并且只管的图像信息，最后反映在胶片上或者屏幕上，其中数学运算出的结果并不一定是真实拍摄到的场景。**换句话说，计算机成像是图像处理的显示方法。**
###Computer Vision
Computer Vision就是计算机视觉。计算机视觉是使用计算机及相关设备对生物视觉的一种模拟。它的主要任务就是通过对采集的图片或视频进行处理以获得相应场景的三维信息，就像人类和许多其他类生物每天所做的那样。** 换句话说，计算机视觉是图像处理中的采集端 。**
###Image Processing

Image processing即图像处理。图像处理一般指数字图像处理。数字图像是指用工业相机、摄像机、扫描仪等设备经过拍摄得到的一个大的**二维数组**，该数组的元素称为像素，其值称为灰度值。

故三者关系大致是

	Reality -> Computer Vision -> Image Processing -> Computer Imaging.

若以linux平台为例，则几个系统可粗略替代为：

	Reality -> V4l2 -> openCV -> opengl.


##2. DFT&FFT

上个学期曾经为了研究**DFT**和**FFT**专门写了一个用于测试两者效率的软件**SimpleFFT**（*https://github.com/godka/simplefft*）。该软件可以详细的给出两者在不同图像下的差距。当然差距是明显的。
###DFT的原理
DFT公式是连续傅里叶变换函数的离散表示。单变量连续函数f(x)的傅里叶变换F(u)定义为：
$$ F(u) = \int_{-\infty}^{+\infty}f(x)e^{-2\pi iux}\text{ d}x$$
故在离散化后单变量离散函数f(x)(x=0,1,2,...,M-1)的傅里叶变换F(u)定义为

$$ F(u) = \frac{1}{M}\sum_{x=0}^{M-1}f(x)e^{-2i\pi uxM} $$
其中$$u=0,1,2,3......M-1$$
根据欧拉公式$$ e^{i\theta} = cos\theta + icos\theta $$
带入一维离散傅里叶变换公式可得

$$ f(u) = \frac{1}{M}\sum_{x=0}^{M-1}f(x)(\frac{cos2\pi ux}{M} - \frac{sin2\pi ux}{M} i) $$
其中，在计算机算法中，\\(\frac{cos2\pi ux}{M} - \frac{sin2\pi ux}{M} i\\)是可以通过叠加的方法复用的。**故一般将它们代写做w。**这样离散傅里叶变换时间将会减少很多。
###二维DFT
离散傅里叶变换很容易扩展到二维，一个尺寸为M*N大小图像的二维傅里叶变换的公式为

$$F(u,v) = \frac{1}{MN}\sum_{x=0}^{M-1}\sum_yf(x,y)e^{-2i\pi(ux/M+vy/N)}$$
由于傅里叶变换的分离特性，我们很容易从一维傅里叶变换得到二维傅里叶变换。我们可以**首先计算每一行的一维傅里叶变换，然后进行每一列的一维傅里叶变换，变换的结果即为二维的傅里叶变换**（也可以先计算列，后计算行，傅里叶变换的可分离性）。其傅里叶反变换的过程是一样的（首先对行进行反傅里叶变换，然后对列进行反傅里叶变换，或者次序颠倒）。
###FFT
以下摘自我的开源项目**SimpleFFT**（*https://github.com/godka/simplefft*）。代码中只要输入一个double[]数组即可完成fft的蝶形迭代。

```
public static int testfft(double[] source)
{
	var t1 = Environment.TickCount;
    simplefft fft = new simplefft();
    Console.Write("fft:");
    fft.simple_fft(source);
    return Environment.TickCount - t1;
}

public Complex[] simple_fft(Complex[] _tmpsource)
{
	var _len = _tmpsource.Length;
	//end of loop
	if (_len == 1)
	{
		return _tmpsource;
    }
    else
    {
		Complex[] ret = new Complex[_len];
		List<Complex> _xodd_list = new List<Complex>();
		List<Complex> _xeven_list = new List<Complex>();
		for (int i = 0; i < _len; i++)
		{
			var tmp = _tmpsource[i];
			if (i % 2 == 0)
				_xeven_list.Add(tmp);
			else
				_xodd_list.Add(tmp);
		}
		//start loop
		var Xoddlist = simple_fft(_xodd_list.ToArray());
		var Xevenlist = simple_fft(_xeven_list.ToArray());

		//merge
		for (int i = 0; i < _len / 2; i++)
		{
			ret[i] = (Xevenlist[i] + Xoddlist[i] * w(i, _len)) / 2;
			ret[i + _len / 2] = (Xevenlist[i] - Xoddlist[i] * w(i, _len)) / 2;
		}
		return ret;
	}
}

```


##3. 图像复原
空域:
$$f(x,y)=Q[g(x,y)]$$
频域:
$$f(x,y)=ifft(\sum_{x=0}^{M-1}\sum_{y=0}^{N-1} h(x,y)*fft(g(x,y)))$$

##4. 小波变换vs傅里叶变换
小波变换与傅里叶变换相比，是一个时间和频率的局部变换，具有良好的空间域和频率域局部化特性，因而能有效的从信号中提取信息，通过伸缩和平移等运算功能，对函数或信号进行多尺度细化分析，对高频采用逐渐精细的时域或空域步长，可以聚焦到分析对象的任意细节，解决了Fourier变换不能解决的许多难题。

##5. DCT&JPG
上学期曾经为了课程与机器学习专门制作了一个开源项目**SimpleDCT**(*https://github.com/godka/simpleDCT*)。该项目主要讲mnist训练集中的所有数据DCT之后重新导入机器学习库，然而最终效果不好。
###DCT#
离散余弦变换是一种与傅立叶变换紧密相关的数学运算。在傅立叶级数展开式中，如果被展开的函数是实偶函数，那么其傅立叶级数中只包含**余弦项**，再将其离散化可导出余弦变换，因此称之为离散余弦变换。
对图像进行二维DCT变换后，图像的频谱数据（频幅）出现在图像的**左上角上**，而高频数据出现在图像的右下角上，离左上角距离越远，所对应的频谱越大。在图像的分析中，我们根据对图像进行DCT变换得出一种有用的统计规律，即图像的能量谱集中在低频部分，这也是图像数据压缩的重要理论依据。对于离散的数字信号，余弦变换为离散形式的DCT。它是图像压缩中非常常用的一种变换编码方法。

```
public static Matrix DCT(Matrix mat){
	int width = mat.Rows;
	int height = mat.Columns;
	double[] a = new double[width * height];
	for (int i = 0; i < height; i++) {
		for (int j = 0; j < width; j++) {
			double ci = 0;
			if (i == 0) {
				ci = Math.Sqrt ((double)1 / (double)width);
			} else {
				ci = Math.Sqrt ((double)1 / (double)width);
			}
			a [i * height + j] = ci * Math.Cos ((j + 0.5) * i * Math.PI / width);
		}
	}
	Matrix tmpa = new Matrix (width, height, a);
	Matrix tmpa_t = tmpa.Transpose ();
	return tmpa * mat * tmpa_t;
}
```

###JPG
JPG压缩算法主要是先DCT之后再进行量化。以下matlab代码展示了一个简单的bmp图片经过一系列步骤后显示的过程。该步骤详细的流程如下：

```
start->bmp2RGB->RGB2yuv->DCT->Quantization->end

```

matlab代码如下所示：

```
RGB=imread('lena.bmp');%读取图片
%rgb->yuv
YUV=rgb2ycbcr(RGB);
n = 8;
[cc,rr] = meshgrid(0:n-1);
T = sqrt(2 / n) * cos(pi * (2*cc + 1) .* rr / (2 * n));
T(1,:) = T(1,:) / sqrt(2);
%进行DCT变换 BY BU BV是double类型
BY=blkproc(Y,[8 8],'P1*x*P2',T,T');
BU=blkproc(U,[8 8],'P1*x*P2',T,T');
BV=blkproc(V,[8 8],'P1*x*P2',T,T');

a=[16 11 10 16 24 40 51 61;
      12 12 14 19 26 58 60 55;
      14 13 16 24 40 57 69 55;
      14 17 22 29 51 87 80 62;
      18 22 37 56 68 109 103 77;
      24 35 55 64 81 104 113 92;
      49 64 78 87 103 121 120 101;
      72 92 95 98 112 100 103 99;]; %量化值
  
  b=[17 18 24 47 99 99 99 99;
      18 21 26 66 99 99 99 99;
      24 26 56 99 99 99 99 99;
      47 66 99 99 99 99 99 99;
      99 99 99 99 99 99 99 99;
      99 99 99 99 99 99 99 99;
       99 99 99 99 99 99 99 99;
       99 99 99 99 99 99 99 99;];
    
   %BY2 BU2 BV2是double类型
   BY2=blkproc(BY,[8 8],'x./P1',a);
   BU2=blkproc(BU,[8 8],'x./P1',b);
   BV2=blkproc(BV,[8 8],'x./P1',b);
   %这里进行取整量化,BY3 BU3 BV3是uint8类型
   BY3=int8(BY2);
   BU3=int8(BU2);
   BV3=int8(BV2);
   
   %BY4 BU4 BV4是double类型
   BY4=blkproc(double(BY3),[8 8],'x.*P1',a);
   BU4=blkproc(double(BU3),[8 8],'x.*P1',b);
   BV4=blkproc(double(BV3),[8 8],'x.*P1',b);
   
   %测试代码
   %BY4=blkproc(BY2,[8 8],'x.*P1',a);
   %BU4=blkproc(BU2,[8 8],'x.*P1',b);
   %BV4=blkproc(BV2,[8 8],'x.*P1',b);
   
   mask=[
         1 1 1  1 1 1 1 1;
         1 1 1  1 1 1 1 1;
         1 1 1  1 1 1 1 1;
         1 1 1  1 1 1 1 1;
         1 1 1  1 1 1 1 1;
         1 1 1  1 1 1 1 1;
         1 1 1  1 1 1 1 1;
         1 1 1  1 1 1 1 1;];
     %BY5 BU5 BV5是double类型
     BY5=blkproc(BY4,[8 8],'P1.*x',mask);
     BU5=blkproc(BU4,[8 8],'P1.*x',mask);
     BV5=blkproc(BV4,[8 8],'P1.*x',mask);
     
     %YI UI VI是double类型
     YI=blkproc(double(BY5),[8 8],'P1*x*P2',T',T);
     UI=blkproc(double(BU5),[8 8],'P1*x*P2',T',T);
     VI=blkproc(double(BV5),[8 8],'P1*x*P2',T',T);
   
   %YUVI是double类型
    YUVI=cat(3,uint8(YI),uint8(UI),uint8(VI));%经过DCT变换和量化后的YUV图像
    figure,imshow(YUVI),title('经过DCT变换和量化后的YUV图像');
    
    RI=YI-0.001*UI+1.402*VI;
    GI=YI-0.344*UI-0.714*VI;
    BI=YI+1.772*UI+0.001*VI;
    RGBI=cat(3,RI,GI,BI);%经过DCT变换和量化后的YUV图像
    RGBI=uint8(RGBI);
    figure,imshow(RGBI),title('经过DCT变换和量化后的RGB图像');
```